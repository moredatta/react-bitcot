"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = void 0;
const graphql_1 = require("graphql");
/**
 * Executes graphql operation
 *
 * In case of mutation/query it returns ExecutionResult
 * In case of subscriptions it returns AsyncIterator of ExecutionResults (only if useSubscriptions is true)
 */
async function execute({ connection, connectionManager, context, event, fieldResolver, lambdaContext = {}, onOperation, operation, pubSub, rootValue, schema, subscriptionManager, registerSubscriptions = false, typeResolver, validationRules = [], }) {
    // extract query from operation (parse if is string);
    const document = typeof operation.query !== "string"
        ? operation.query
        : graphql_1.parse(operation.query);
    // this is internal context that should not be used by a user in resolvers
    // this is only added to provide access for PubSub to get connection managers and other
    // internal stuff
    const internalContext = {
        event,
        lambdaContext,
        $$internal: {
            connection,
            connectionManager,
            operation,
            pubSub,
            registerSubscriptions,
            subscriptionManager,
        },
    };
    console.log("internalContext", internalContext);
    // context stored in connection state
    const connectionContext = connection.data ? connection.data.context : {};
    console.log("connectionContext", connectionContext);
    // instantiate context
    const contextValue = typeof context === "function"
        ? await context({
            ...internalContext,
            ...connectionContext,
        })
        : context;
    console.log("contextValue", contextValue);
    // detect operation type
    const operationAST = graphql_1.getOperationAST(document, operation.operationName || "");
    console.log("operationAST", document, operation.operationName || "", operationAST);
    const baseParams = {
        context: {
            ...connectionContext,
            ...contextValue,
            ...internalContext,
        },
        operationName: operation.operationName,
        query: document,
        schema,
        variables: operation.variables,
    };
    console.log("baseParams", baseParams);
    let promisedParams = Promise.resolve(baseParams);
    console.log("promisedParams", promisedParams);
    if (onOperation) {
        console.log("onOperation");
        promisedParams = Promise.resolve(onOperation(operation, baseParams, connection));
    }
    const params = await promisedParams;
    if (!params || typeof params !== "object") {
        throw new Error("`onOperation()` must return an object.");
    }
    if (!params.schema) {
        throw new Error("Missing schema parameter!");
    }
    // validate document
    const validationErrors = graphql_1.validate(schema, document, [
        ...graphql_1.specifiedRules,
        ...validationRules,
    ]);
    console.log("validationErrors", validationErrors);
    if (validationErrors.length > 0) {
        return {
            errors: validationErrors,
        };
    }
    const processedContext = {
        ...params.context,
        ...internalContext,
        $$internal: {
            ...params.context.$$internal,
            ...internalContext.$$internal,
        },
    };
    console.log("got processedContext");
    if (operationAST && operationAST.operation === "subscription") {
        console.log("[operationAST.operation]", operationAST.operation, {
            document,
            operationName: params.operationName,
            rootValue,
            schema: params.schema || schema,
            variableValues: params.variables,
        });
        return graphql_1.subscribe({
            contextValue: processedContext,
            document,
            fieldResolver,
            operationName: params.operationName,
            rootValue,
            schema: params.schema || schema,
            variableValues: params.variables,
        });
    }
    console.log("gqlExecute", {
        contextValue: processedContext,
        document,
        fieldResolver,
        operationName: params.operationName,
        rootValue,
        schema: params.schema || schema,
        typeResolver,
        variableValues: params.variables,
    });
    return graphql_1.execute({
        contextValue: processedContext,
        document,
        fieldResolver,
        operationName: params.operationName,
        rootValue,
        schema: params.schema || schema,
        typeResolver,
        variableValues: params.variables,
    });
}
exports.execute = execute;
//# sourceMappingURL=execute.js.map