"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventProcessor = void 0;
// import { DynamoDB } from 'aws-sdk';
const iterall_1 = require("iterall");
const ArrayPubSub_1 = require("./ArrayPubSub");
const formatMessage_1 = require("./formatMessage");
const execute_1 = require("./execute");
const protocol_1 = require("./protocol");
/**
 * DynamoDBEventProcessor
 *
 * Processes DynamoDB stream event in order to send events to subscribed clients
 */
class EventProcessor {
    constructor(options = {}) {
        this.onError = options.onError || ((err) => console.log(err));
        this.debug = options.debug || false;
    }
    createHandler(server) {
        return async (lambdaEvent, lambdaContext) => {
            const connectionManager = server.getConnectionManager();
            const subscriptionManager = server.getSubscriptionManager();
            // const { Records } = lambdaEvent;
            // for (const record of Records) {
            const event = lambdaEvent; // JSON.parse(lambdaEvent)
            // process only INSERT events
            // if (record.eventName !== 'INSERT') {
            //   continue;
            // }
            // // now construct event from dynamodb image
            // const event: IDynamoDBSubscriptionEvent = DynamoDB.Converter.unmarshall(
            //   record.dynamodb!.NewImage as any,
            // ) as any;
            // // skip if event is expired
            // if (isTTLExpired(event.ttl)) {
            //   if (this.debug) console.log('Discarded event : TTL expired', event);
            //   continue;
            // }
            // iterate over subscribers that listen to this event
            // and for each connection:
            //  - create a schema (so we have subscribers registered in PubSub)
            //  - execute operation from event againt schema
            //  - if iterator returns a result, send it to client
            //  - clean up subscriptions and follow with next page of subscriptions
            //  - if the are no more subscriptions, process next event
            // make sure that you won't throw any errors otherwise dynamo will call
            // handler with same events again
            for await (const subscribers of subscriptionManager.subscribersByEvent(event)) {
                const promises = subscribers
                    .map(async (subscriber) => {
                    // create PubSub for this subscriber
                    const pubSub = new ArrayPubSub_1.ArrayPubSub([event]);
                    const options = await server.createGraphQLServerOptions(lambdaEvent, lambdaContext, {
                        // this allows createGraphQLServerOptions() to append more extra data
                        // to context from connection.data.context
                        connection: subscriber.connection,
                        operation: subscriber.operation,
                        pubSub,
                    });
                    // execute operation by executing it and then publishing the event
                    const iterable = await execute_1.execute({
                        connectionManager,
                        subscriptionManager,
                        schema: options.schema,
                        event: lambdaEvent,
                        lambdaContext,
                        context: options.context,
                        connection: subscriber.connection,
                        operation: subscriber.operation,
                        pubSub,
                        registerSubscriptions: false,
                    });
                    if (!iterall_1.isAsyncIterable(iterable)) {
                        // something went wrong, probably there is an error
                        return Promise.resolve();
                    }
                    const iterator = iterall_1.getAsyncIterator(iterable);
                    const result = await iterator.next();
                    if (this.debug)
                        console.log('Send event ', result);
                    if (result.value != null) {
                        return connectionManager.sendToConnection(subscriber.connection, formatMessage_1.formatMessage({
                            id: subscriber.operationId,
                            payload: result.value,
                            type: protocol_1.SERVER_EVENT_TYPES.GQL_DATA,
                        }));
                    }
                    return Promise.resolve();
                })
                    .map((promise) => promise.catch(this.onError));
                await Promise.all(promises);
            }
            // }
        };
    }
}
exports.EventProcessor = EventProcessor;
//# sourceMappingURL=EventProcessor.js.map